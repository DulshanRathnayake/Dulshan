from google.colab import drive
drive.mount('/content/drive')

!git clone https://github.com/DulshanRathnayake/Dulshan.git

%cd Image-Processing-Assignment-1/

import cv2
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

def gaussian_derivative_kernel(size, sigma, direction="x"):
    k = size // 2
    kernel = np.zeros((size, size), dtype=np.float32)

    for x in range(-k, k + 1):
        for y in range(-k, k + 1):
            G = np.exp(-(x**2 + y**2) / (2 * sigma**2))
            if direction == "x":
                kernel[x + k, y + k] = -(x / (sigma**2)) * G
            else:
                kernel[x + k, y + k] = -(y / (sigma**2)) * G

    # Normalize for stability
    kernel /= np.sum(np.abs(kernel))
    return kernel

dog_x_5 = gaussian_derivative_kernel(5, sigma=2, direction="x")
dog_y_5 = gaussian_derivative_kernel(5, sigma=2, direction="y")

print("5×5 DoG Kernel (X-direction):\n", dog_x_5)
print("5×5 DoG Kernel (Y-direction):\n", dog_y_5)

dog_x_51 = gaussian_derivative_kernel(51, sigma=2, direction="x")

x = np.arange(-25, 26)
y = np.arange(-25, 26)
X, Y = np.meshgrid(x, y)

fig = plt.figure(figsize=(8,6))
ax = fig.add_subplot(111, projection='3d')
ax.plot_surface(X, Y, dog_x_51)

ax.set_title("3D Surface of Derivative-of-Gaussian (X-direction)")
ax.set_xlabel("X")
ax.set_ylabel("Y")
ax.set_zlabel("Amplitude")

plt.show()

img = cv2.imread("/content/1.jpeg", cv2.IMREAD_GRAYSCALE)

if img is None:
    print("Warning: Image '/content/drive/MyDrive/Image Processing Assognment/runway.png' not found. Creating a dummy grayscale image.")
    img = np.zeros((200, 300), dtype=np.uint8) # Create a black dummy image
    cv2.putText(img, "Dummy Image", (50, 100), cv2.FONT_HERSHEY_SIMPLEX, 1, 255, 2, cv2.LINE_AA)

def manual_convolution(image, kernel):
    h, w = image.shape
    k = kernel.shape[0] // 2
    padded = np.pad(image, k, mode='edge')
    output = np.zeros_like(image, dtype=np.float32)

    for i in range(h):
        for j in range(w):
            region = padded[i:i+2*k+1, j:j+2*k+1]
            output[i, j] = np.sum(region * kernel)

    return output

grad_x_manual = manual_convolution(img, dog_x_5)
grad_y_manual = manual_convolution(img, dog_y_5)

# Gradient magnitude
grad_mag_manual = np.sqrt(grad_x_manual**2 + grad_y_manual**2)

plt.figure(figsize=(12,4))

plt.subplot(1,3,1)
plt.imshow(grad_x_manual, cmap='gray')
plt.title("Gradient X (Manual DoG)")
plt.axis("off")

plt.subplot(1,3,2)
plt.imshow(grad_y_manual, cmap='gray')
plt.title("Gradient Y (Manual DoG)")
plt.axis("off")

plt.subplot(1,3,3)
plt.imshow(grad_mag_manual, cmap='gray')
plt.title("Gradient Magnitude (Manual)")
plt.axis("off")

plt.tight_layout()
plt.show()

grad_x_sobel = cv2.Sobel(img, cv2.CV_64F, 1, 0, ksize=5)
grad_y_sobel = cv2.Sobel(img, cv2.CV_64F, 0, 1, ksize=5)

grad_mag_sobel = np.sqrt(grad_x_sobel**2 + grad_y_sobel**2)

plt.figure(figsize=(12,4))

plt.subplot(1,3,1)
plt.imshow(grad_x_sobel, cmap='gray')
plt.title("Gradient X (Sobel)")
plt.axis("off")

plt.subplot(1,3,2)
plt.imshow(grad_y_sobel, cmap='gray')
plt.title("Gradient Y (Sobel)")
plt.axis("off")

plt.subplot(1,3,3)
plt.imshow(grad_mag_sobel, cmap='gray')
plt.title("Gradient Magnitude (Sobel)")
plt.axis("off")

plt.tight_layout()
plt.show()
